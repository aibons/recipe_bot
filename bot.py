#!/usr/bin/env python
#  bot.py ‚Ä¢ Recipe-Bot (Telegram)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#  ‚Ä¢ long-polling:  initialize ‚Üí start ‚Üí updater.start_polling()
#  ‚Ä¢ –æ—Ç–≤–µ—Ç—ã —ç–∫—Ä–∞–Ω–∏—Ä—É–µ–º  escape_markdown(V2)
#  ‚Ä¢ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ + —Ä–µ—Ü–µ–ø—Ç ‚Üí Markdown V2
#  ‚Ä¢ IG / TikTok / YT-Shorts ‚Äî via cookies
#  ‚Ä¢ —É—Å–∫–æ—Ä–µ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ aria2c (–µ—Å–ª–∏ –µ—Å—Ç—å)
#  ‚Ä¢ health-check –Ω–∞ :8080  (Render Free)
#  ‚Ä¢ Paywall (–ÆMoney)   ENABLE_PAY = True
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

from __future__ import annotations

# ===== —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ =====
import asyncio, datetime as dt, json, os, re, sqlite3, subprocess, tempfile, textwrap
from pathlib import Path
import logging, shutil

# ===== —Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ =====
from aiohttp import web
from dotenv import load_dotenv
from yt_dlp import YoutubeDL
from yt_dlp.utils import DownloadError
import openai

from telegram import (
    Update,
    LabeledPrice,
    PreCheckoutQuery,
    SuccessfulPayment,
)
from telegram.helpers import escape_markdown
from telegram.ext import (
    Application,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    PreCheckoutQueryHandler,
    filters,
)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ENV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
load_dotenv()

TOKEN           = os.getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY  = os.getenv("OPENAI_API_KEY")
IG_SESSIONID    = os.getenv("IG_SESSIONID")          # Instagram cookie
TT_SESSIONID    = os.getenv("TT_SESSIONID")          # TikTok cookie (sid_tt)
YT_COOKIES_FILE = os.getenv("YT_COOKIES_FILE")       # cookies_youtube.txt
ENABLE_PAY      = bool(int(os.getenv("ENABLE_PAY", "0")))  # 0/1
OWNER_ID        = int(os.getenv("OWNER_ID", "248610561"))  # –±–µ–∑–ª–∏–º–∏—Ç

openai.api_key = OPENAI_API_KEY
logging.basicConfig(level="INFO", format="%(asctime)s | %(levelname)s | %(name)s | %(message)s")
log = logging.getLogger("recipe_bot")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ yt-dlp BASE OPTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
YDL_BASE = {
    "quiet": True,
    "outtmpl": "%(id)s.%(ext)s",
    "merge_output_format": "mp4",
}


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers ‚îÄ‚îÄ
def escape(s: str) -> str:
    return escape_markdown(str(s), version=2)


def extract_audio(src: Path, dst: Path) -> bool:
    """ffmpeg -> wav (Whisper)"""
    try:
        subprocess.check_call(
            ["ffmpeg", "-y", "-i", src, "-vn", "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1", dst],
            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
        )
        return dst.exists() and dst.stat().st_size > 0
    except subprocess.CalledProcessError:
        return False


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Äî DOWNLOAD ‚Äî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def download(url: str) -> tuple[Path, dict]:
    """
    –°–∫–∞—á–∏–≤–∞–µ—Ç —Ä–æ–ª–∏–∫ (IG / TikTok / YT-Shorts) —Å —É—á—ë—Ç–æ–º –∫—É–∫–æ–≤.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—Ñ–∞–π–ª, meta).
    """
    opts = YDL_BASE.copy()

    # Instagram cookie
    if IG_SESSIONID and "instagram.com" in url:
        ck = Path("ig_cookie.txt")
        if not ck.exists():
            ck.write_text(f".instagram.com\tTRUE\t/\tFALSE\t0\tsessionid\t{IG_SESSIONID}\n")
        opts["cookiefile"] = str(ck)

    # TikTok cookie (sid_tt)
    if TT_SESSIONID and "tiktok.com" in url:
        ck = Path("tt_cookie.txt")
        if not ck.exists():
            ck.write_text(f".tiktok.com\tTRUE\t/\tFALSE\t0\tsid_tt\t{TT_SESSIONID}\n")
        opts["cookiefile"] = str(ck)

    # YouTube cookies.txt
    if YT_COOKIES_FILE and ("youtu.be" in url or "youtube.com" in url):
        opts["cookiefile"] = YT_COOKIES_FILE

    # —É—Å–∫–æ—Ä—è–µ–º —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ
    if shutil.which("aria2c"):
        opts |= {
            "external_downloader": "aria2c",
            "external_downloader_args": ["-x", "8", "-k", "1M"],
        }

    fmts = [
        "bestvideo[height<=720]+bestaudio/best[height<=720]",
        "best[height<=720]",
        "best",
    ]
    last_err = None
    for fmt in fmts:
        try:
            with YoutubeDL({**opts, "format": fmt}) as ydl:
                info = ydl.extract_info(url, download=True)
                return Path(ydl.prepare_filename(info)), info
        except DownloadError as e:
            last_err = e
            continue
    raise RuntimeError(f"–ù–µ —Å–º–æ–≥ —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ: {last_err}")


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Äî —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Markdown ‚Äî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
EMOJI = {
    "–ª–∏–º–æ–Ω": "üçã", "–∫–µ–∫—Å": "üßÅ", "–∫—Ä—ã–ª": "üçó", "–±—É—Ä–≥–µ—Ä": "üçî",
    "–ø–∞—Å—Ç–∞": "üçù", "—Å–∞–ª–∞—Ç": "ü•ó", "—Å—É–ø": "üç≤", "—Ñ—Ä–∏–∫–∞": "ü•ò",
}


def fmt_ing(i: str) -> str:
    return f"‚Ä¢ {escape(i)}"


def fmt_steps(lst: list[str]) -> str:
    return "\n".join(f"{n+1}. {escape(s)}" for n, s in enumerate(lst))


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def cmd_start(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    text = (
        "üî• *Recipe Bot* ‚Äî –ø–æ–º–æ–≥–∞—é —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç –∏–∑ –∫–æ—Ä–æ—Ç–∫–æ–≥–æ –≤–∏–¥–µ–æ!\n\n"
        "üÜì –î–æ—Å—Ç—É–ø–Ω–æ *6* –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö —Ä–æ–ª–∏–∫–æ–≤.\n"
        "*–ü–ª–∞—Ç–Ω—ã–µ —Ç–∞—Ä–∏—Ñ—ã (—Å–∫–æ—Ä–æ):*\n"
        "‚Ä¢ 100 —Ä–æ–ª–∏–∫–æ–≤ ‚Äî 299 ‚ÇΩ\n"
        "‚Ä¢ 200 —Ä–æ–ª–∏–∫–æ–≤ + 30 –¥–Ω–µ–π ‚Äî 199 ‚ÇΩ\n\n"
        "–ü—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ Reels / Shorts / TikTok, –∞ –æ—Å—Ç–∞–ª—å–Ω–æ–µ —è —Å–¥–µ–ª–∞—é —Å–∞–º!"
    )
    await upd.message.reply_text(text, parse_mode="MarkdownV2")


async def handle(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    url = upd.message.text.strip()

    if "instagram.com" not in url and "youtube" not in url and "tiktok" not in url:
        return await upd.message.reply_text("–î–∞–π —Å—Å—ã–ª–∫—É –Ω–∞ Instagram, YouTube Shorts –∏–ª–∏ TikTok üòâ")

    await upd.message.reply_text("üèÉ –°–∫–∞—á–∏–≤–∞—é‚Ä¶")

    # —Å–∫–∞—á–∏–≤–∞–µ–º
    try:
        vid_fn, meta = download(url)
    except Exception as e:
        log.warning("download error: %s", e)
        return await upd.message.reply_text("‚ùå –ù–µ —Å–º–æ–≥ —Å–∫–∞—á–∞—Ç—å —ç—Ç–æ –≤–∏–¥–µ–æ.")

    # ---- –∞—É–¥–∏–æ ‚Üí Whisper
    wav = Path(tempfile.mktemp(suffix=".wav"))
    if not extract_audio(vid_fn, wav):
        return await upd.message.reply_text("‚ùå –ù–µ —Å–º–æ–≥ –∏–∑–≤–ª–µ—á—å –∑–≤—É–∫.")

    whisper_txt = ""
    try:
        with open(wav, "rb") as f:
            wresp = openai.audio.transcriptions.create(
                model="whisper-1", file=f, language="ru", response_format="text"
            )
            whisper_txt = wresp.text
    except Exception as e:
        log.warning("whisper error: %s", e)

    # ---- GPT: —Å—Ç—Ä–æ–∏–º —Ä–µ—Ü–µ–ø—Ç
    try:
        chat = openai.chat.completions.create(
            model="gpt-4o-mini",
            response_format={"type": "json_object"},
            messages=[
                {"role": "system", "content": "–¢—ã –∫—É–ª–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫. –í–µ—Ä–Ω–∏ JSON {title, ingredients[], steps[], extra}"},
                {"role": "user", "content": (meta.get("description") or "") + "\n" + whisper_txt},
            ],
        )
        rec = json.loads(chat.choices[0].message.content)
    except Exception as e:
        log.warning("gpt error: %s", e)
        return await upd.message.reply_text("‚ùå –ù–µ —Å–º–æ–≥ —Ä–∞–∑–æ–±—Ä–∞—Ç—å —Ä–µ—Ü–µ–ø—Ç.")

    # ---- —Ñ–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç
    title = rec.get("title", "–†–µ—Ü–µ–ø—Ç")
    emoji = next((e for k, e in EMOJI.items() if k.lower() in title.lower()), "üçΩÔ∏è")

    lines = [
        f"*{escape(title)}* {emoji}",
        "",
        "*üõí –ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã*",
        *(fmt_ing(i) for i in rec.get("ingredients", [])),
        "",
        "*üë©‚Äçüç≥ –®–∞–≥–∏ –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è*",
        fmt_steps(rec.get("steps", [])),
    ]
    extra = rec.get("extra")
    if extra:
        lines += ["", "*üí° –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ*", escape(extra)]
    lines += ["", "‚∏ª", f"üîó [–û—Ä–∏–≥–∏–Ω–∞–ª]({escape(url)})"]

    text_block = "\n".join(lines)[:4000]

    # ---- –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º
    with open(vid_fn, "rb") as vf:
        await upd.message.reply_video(vf)
    await upd.message.reply_text(text_block, parse_mode="MarkdownV2")

    # ---- cleanup
    for p in (vid_fn, wav):
        try:
            p.unlink()
        except Exception:
            pass


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ paywall (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def buy100(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.message.reply_invoice(
        title="–ü–∞–∫–µ—Ç 100 —Ä–æ–ª–∏–∫–æ–≤",
        description="100 —Å–∫–∞—á–∏–≤–∞–Ω–∏–π —Ä–µ—Ü–µ–ø—Ç–æ–≤",
        payload="buy100",
        provider_token=os.getenv("YUMONEY_TOKEN", ""),
        currency="RUB",
        prices=[LabeledPrice("100 —Ä–æ–ª–∏–∫–æ–≤", 29900)],
    )


async def subscribe(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.message.reply_invoice(
        title="–ü–æ–¥–ø–∏—Å–∫–∞ 30 –¥–Ω–µ–π + 200 —Ä–æ–ª–∏–∫–æ–≤",
        description="30 –¥–Ω–µ–π –±–µ–∑–ª–∏–º–∏—Ç–∞ (–¥–æ 200 —à—Ç)",
        payload="sub200",
        provider_token=os.getenv("YUMONEY_TOKEN", ""),
        currency="RUB",
        prices=[LabeledPrice("–ü–æ–¥–ø–∏—Å–∫–∞", 19900)],
    )


async def prechk(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.bot.answer_pre_checkout_query(upd.pre_checkout_query.id, ok=True)


async def paid(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await upd.message.reply_text("‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∞! –°–∫–æ—Ä–æ —Ç–∞—Ä–∏—Ñ—ã –∑–∞—Ä–∞–±–æ—Ç–∞—é—Ç üòâ")


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ AioHTTP health ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def aio_app():
    app = web.Application()

    async def health(req):
        return web.json_response({"status": "ok"})

    app.router.add_get("/health", health)
    return app


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MAIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def main():
    app = Application.builder().token(TOKEN).build()

    # handlers
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle))

    if ENABLE_PAY:
        app.add_handler(CommandHandler("buy100", buy100))
        app.add_handler(CommandHandler("subscribe", subscribe))
        app.add_handler(PreCheckoutQueryHandler(prechk))
        app.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, paid))

    await app.initialize()  # –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞

    # –∑–∞–ø—É—Å–∫–∞–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ: Telegram-–±–æ—Ç + health-—Å–µ—Ä–≤–µ—Ä
    await asyncio.gather(
        app.start(),
        app.updater.start_polling(),
        web._run_app(aio_app(), host="0.0.0.0", port=8080),
    )


if __name__ == "__main__":
    asyncio.run(main())